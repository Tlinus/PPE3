/**
 * Created by Mika on 20/01/2016.
 */
exports.conversationManager = {

    init: function (userId) {

        this.userId = userId;

        var userId = userId;

        this.openRoom = function (userIds) { // appel existeOneConv avec un nom plus explicite
            this.existeOneConv(userIds);
        };

        this.existeOneConv = function (userIds) { // verifie que l'utilisateur a au moins une conversation avant d'en créer une
            sqlConnection.query('SELECT id_conversation FROM participant_conversation WHERE id_utilisateur=' + this.userId,
                function (error, results) {
                    if (error) {
                        console.log(error);
                        return;
                    }
                    if (results.length > 0) {
                        for (var resultsIndex in results) {
                            users[userId].socket.conversationManager.conversationAlreadyExist(userIds)
                        }
                    } else {
                        users[userId].socket.conversationManager.createConversation(userIds);
                    }
                });
        };

        this.createConversation = function (conversationUsers) { // crée une conversation avec la liste d'id des utilisateur
            console.log('create conversation');
            sqlConnection.query('INSERT INTO conversation (id) VALUES ("")',
                function select(error, results, fields) {
                    if (error) {
                        console.log(error);
                        return;
                    }
                    sqlConnection.query('SELECT id FROM conversation ORDER BY id DESC LIMIT 1',
                        function select(error, results, fields) {
                            if (error) {
                                console.log(error);
                                return;
                            }
                            var newRoomId = results[0].id;
                            for (var conversationUsersIndex in conversationUsers) {
                                sqlConnection.query('INSERT INTO participant_conversation (id_conversation,id_utilisateur) VALUES (' + newRoomId + ',' + conversationUsers[conversationUsersIndex] + ')',
                                    function (error, results, fields) {
                                        if (error) {
                                            console.log(error);
                                            return;
                                        }
                                    });
                            }

                            for (var conversationUsersIndex in conversationUsers) {
                                if (users[conversationUsers[conversationUsersIndex]] !== undefined) {
                                    users[conversationUsers[conversationUsersIndex]].socket.join(newRoomId); //accées au tableau pour avoir accées a la methode joins propre au socket correspondant a l'utilisateur
                                }
                            }
                            users[userId].socket.emit('newRoom', newRoomId);
                            return;
                        });
                });
        };

        this.conversationAlreadyExist = function (userIdList) { //verifie qu'il n'existe pas une conversation en bdd avec les memes utilisateurs
            var userIdArray = [];
            for (var index in userIdList) {
                userIdArray.push(parseInt(userIdList[index]));
            }
            sqlConnection.query('SELECT id_conversation FROM participant_conversation WHERE id_utilisateur=' + userId,
                function (error, results) {
                    if (error) {
                        console.log(error);
                        return;
                    }

                    if (results.length > 0) {
                        for (var resultsIndex in results) {
                            var idConv = results[resultsIndex].id_conversation;
                            sqlConnection.query('SELECT id_utilisateur FROM participant_conversation WHERE id_conversation=' + idConv,
                                function (error, results) {
                                    if (error) {
                                        console.log(error);
                                    }

                                    for (var resultsIndex in results) {
                                        console.log('userId: ' + results[resultsIndex].id_utilisateur + '; indexOf: ' + userIdArray.indexOf(results[resultsIndex].id_utilisateur) + '; userIdList :' + userIdList + '; results :' + results);
                                        if (userIdArray.indexOf(results[resultsIndex].id_utilisateur) < 0 || results.length != userIdList.length) {
                                            break;
                                        } else {
                                            console.log('existing room');
                                            users[userId].socket.conversationManager.getConversation(idConv, 0);
                                            return;
                                            console.log('test');
                                        }
                                    }
                                    console.log('no existing room');
                                    users[userId].socket.conversationManager.createConversation(userIdList);
                                    return;
                                })
                        }
                    }
                });
        };

        this.getConversation = function (idConversation, offset) { //recupere les messages d'une conversation par tranche de 25
            if (offset > 0)
                offset = 25 * offset;
            sqlConnection.query('SELECT * FROM message WHERE id_conversation=' + idConversation + ' LIMIT 25 OFFSET ' + offset,
                function (error, results, fields) {
                    if (error) {
                        console.log(error);
                        return;
                    }

                    if (results.lenght > 0) {
                        var messages = [];
                        for (var resultsIndex in results) {
                            messages.push({
                                from: results[resultsIndex].id_utilisateur,
                                message: results[resultsIndex].message
                            });
                        }

                    }
                });
        };

        this.getConverseNotif = function () { //censé recuperer les conversations dont le dernier message date de quand l'utilisateur etait deco, fonctionne pas parce qu'il faudrait que getConversation puisse return ses resultats
            sqlConnection.query('SELECT id_conversation FROM message JOIN utilisateur ON utilisateur.id=message.id_utilisateur WHERE date_message > last_connection && utilisateur.id=' + this.userId + ' GROUP BY id_conversation ORDER BY date_message DESC',
                function (error, results, fields) {
                    if (error) {
                        console.log(error);
                        return;
                    }
                    var converseNotif = [];
                    if (results.length > 0) {
                        for (var resultsIndex in results) {
                            converseNotif.push({
                                'id': results[resultsIndex].id_conversation,
                                messages: getConversation(results[resultsIndex].id_conversation, 0)
                            });
                        }
                        return converseNotif;
                    } else {
                        return false;
                    }
                })
        };

        this.openRooms = [];
    }
}